# 6 正規表現

## 6.3 Rubyにおける正規表現オブジェクト

### `=~` でのマッチ
```ruby
# マッチすれば位置、しなければ nil が返る
'Postal Code: 123-4567' =~ /\d{3}-\d{4}/  # => 13
'hello' =~ /\d{3}-\d{4}/  # => nil

# true / false での判定にも使える
!!('Postal Code: 123-4567' =~ /\d{3}-\d{4}/)  # => true
!!('hello' =~ /\d{3}-\d{4}/)  # => false
```

### `!~` でのマッチ（論理否定）
```ruby
# マッチしなければ true、すれば false が返る
'hello' !~ /\d{3}-\d{4}/  # => true
'Postal Code: 123-4567' !~ /\d{3}-\d{4}/  # => false
```

### キャプチャ
```ruby
text = '私の誕生日は1977年7月17日です。'

m = /(\d+)年(\d+)月(\d+)日/.match(text)
# String と Regexp を入れ換えてもOK
m = text.match(/(\d+)年(\d+)月(\d+)日/)

m  # => #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
m[0]  # => "1977年7月17日"
m[1]  # => "1977"
m[2]  # => "7"
m[3]  # => "17"
m[1..3]  # => ["1977", "7", "17"]
```

### キャプチャ（名前付き）
```ruby
text = '私の誕生日は1977年7月17日です。'

m = /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/.match(text)
m  # => #<MatchData "1977年7月17日" year:"1977" month:"7" day:"17">

# シンボル、文字列、添字で取得
m[:year]   # => "1977"
m[:month]  # => "7"
m['day']   # => "17"
m[2]       # => "7"
m[1..3]    # => ["1977", "7", "17"]
```

### 名前付きキャプチャでマッチ文字列をローカル変数として使う
```ruby
text = "私の誕生日は1977年7月17日です。"

# 正規表現と対象文字列は入れ換え不可（正規表現が左辺）
if /(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/ =~ text
  puts "#{year}-#{month}-#{day}"
end
# => 1977-7-17
```

### Stringクラスのメソッドと組み合わせ

- scan
  - マッチ部分を配列に格納
  ```ruby
  '123 456 789'.scan(/\d+/)  # => ["123", "456", "789"]
  '1977年7月17日 2016年12月31日'.scan(/(\d+)年(\d+)月(\d+)日/)
  # => [["1977", "7", "17"], ["2016", "12", "31"]]

  # "?:" でキャプチャしない部分を指定可能
  '1977年7月17日 2016年12月31日'.scan(/(?:\d+)年(\d+)月(\d+)日/)
  # => [["7", "17"], ["12", "31"]]
  '1977年7月17日 2016年12月31日'.scan(/(?:\d+)年(?:\d+)月(?:\d+)日/)
  # => ["1977年7月17日", "2016年12月31日"]
  ```

- `[]` / `slice` / `slice!`
  - マッチ部分の文字列を抜き出す
  - マッチ部分が複数あれば最初にマッチした文字列が返る
  ```ruby
  text = '郵便番号は123-4567 456-7890です'
  text[/\d{3}-\d{4}/]  # => "123-4567"

  # 第2引数で取得するキャプチャ箇所を指定
  text = '私の誕生日は1977年7月17日です。'
  text[/(\d+)年(\d+)月(\d+)日/]           # => "1977年7月17日"
  text[/(\d+)年(\d+)月(\d+)日/, 1]        # => "1977"
  text.slice(/(\d+)年(\d+)月(\d+)日/, 3)  # => "17"
  ```

- `split`
  - 正規表現にマッチする部分で文字列を分割する
  ```ruby
  text = '123,456-789'
  text.split(/,|-/)  # => ["123", "456", "789"]
  ```

- `gsub` / `gsub!`
  - マッチ部分を指定文字列で置換する
  ```ruby
  text = '123,456-789'
  text.gsub(/,|-/, ':')  # => "123:456:789"

  # キャプチャ
  text = '私の誕生日は1977年7月17日です。'
  text.gsub(/(\d+)年(\d+)月(\d+)日/, '\1-\2-\3')
  # => "私の誕生日は1977-7-17です。"
  text.gsub(/(?<year>\d+)年(?<month>\d+)月(?<day>\d+)日/, '\k<year>-\k<month>-\k<day>')
  # => "私の誕生日は1977-7-17です。"

  # ハッシュで置換ルールを渡す
  text = '123,456-789'
  hash = { ',' => ':', '-' => '/' }
  text.gsub(/,|-/, hash)  # => "123:456/789"

  # ブロックの戻り値で置換
  text = '123,456-789'
  # "," は ":" に、それ以外は "/" に置換
  text.gsub(/,|-/) { |matched| matched == ',' ? ':' : '/' }
  # => "123:456/789"
  ```


## 6.5 正規表現オブジェクトについてもっと詳しく

- 正規表現オブジェクトの生成
  ```ruby
  Regexp.new('\d{3}-\d{4}')  # => /\d{3}-\d{4}/

  # %記法で生成（"/"のエスケープが不要）
  /http:\/\/example\.com\//  # => /http:\/\/example\.com\//
  %r!http://example\.com/!   # => /http:\/\/example\.com\//
  %r{http://example\.com/}   # => /http:\/\/example\.com\//

  # 変数展開
  pattern = '\d{3}-\d{4}'
  /#{pattern}/  # => /\d{3}-\d{4}/
  ```

- case文で正規表現を使う
  - when句に正規表現を指定可能

- 組み込み変数でキャプチャ文字列取得
  ```ruby
  text = '私の誕生日は1977年7月17日です。'
  text =~ /(\d+)年(\d+)月(\d+)日/  # => 6

  $~  # => #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
  $&  # => "1977年7月17日"
  $1  # => "1977"
  $2  # => "7"
  $3  # => "17"
  # 最後のキャプチャ文字列
  $+  # => "17"
  ```

- `Regexp.last_match` でのマッチ結果取得
  ```ruby
  text = '私の誕生日は1977年7月17日です。'
  text =~ /(\d+)年(\d+)月(\d+)日/  # => 6

  Regexp.last_match
  # => #<MatchData "1977年7月17日" 1:"1977" 2:"7" 3:"17">
  Regexp.last_match(1)  # => "1977"
  Regexp.last_match(2)  # => "7"
  Regexp.last_match(3)  # => "17"
  # 最後のマッチ
  Regexp.last_match(-1)  # => "17"
  ```

- `match?` メソッド
  - Ruby 2.4以降
  - `Regexp.last_match` や `$` を書き換えないため高速
  ```ruby
  /\d{3}-\d{4}/.match?('123-4567')
  # => true
  '123-4567'.match?(/\d{3}-\d{4}/)
  # => true
  ```
